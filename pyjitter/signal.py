from collections import namedtuple
from enum import IntEnum
from typing import List, Tuple


Edge = namedtuple('Edge',
                  [
                      'time',       # Average transition time
                      'end_level',  # End level of the transition
                      'trans_time',     # duration of the transition
                      'uncertainty',    # total transition time variation

                  ])


class Signal:
    def __init__(self, name):
        self.name = name
        # A signal can have it's own _edges (it's independent)
        self._edges: List[Edge] = []

        # Or it can be generated by a connection to another signal
        self.connection = None

        # In any case, it will have an initial state
        self.initial_state = Signal.Level.X

        # Default rise/fall times
        self.rise_time = 1e-9
        self.fall_time = 1e-9

    class Level(IntEnum):
        LOW = 0
        HIGH = 1
        Z = 2  # High Impedance
        X = 3  # Don't care
        D = 4  # Bus value

    def add_edge(self, time, level, uncertainty=0):
        """
        Adds an edge to a signal. Rise/Fall times are calculated based on the
        signal `rise_time` and `fall_time` properties.

        If the the signal is already at the given level, no edge is added.

        :param time: average time of the transition (middle of the uncertainty)
        :param level: Signal.Level to which the transition goes
        :param uncertainty: total uncertainty time
        :return: None
        """

        if self.independent:
            if self.prev_level != level:
                self._edges.append(
                    Edge(time, level, self.transition_time_to_level(level),
                         uncertainty)
                )
        else:
            raise(ValueError("Cannot add an edge to a non-independent signal."
                             "Remove the connection to other signals to make"
                             "it independent first."))

    @property
    def independent(self):
        return self.connection is None

    @property
    def prev_level(self):
        try:
            return self._edges[-1].end_level
        except IndexError:
            return self.initial_state

    @property
    def edges(self) -> Tuple[Edge]:
        if self.independent:
            return tuple(self._edges)
        else:
            return tuple(self.connection.calculate_edges())

    def transition_time_to_level(self, level):
        max_time = max(self.rise_time, self.fall_time)
        trans_time_table = {
            Signal.Level.HIGH: self.rise_time,
            Signal.Level.LOW: self.fall_time,
            Signal.Level.Z: max_time,
            Signal.Level.X: max_time,
            Signal.Level.D: max_time,
        }

        return trans_time_table[level]

